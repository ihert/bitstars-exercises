<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>three.js demo</title>
    <style>
        body{margin: 0; overflow: hidden;}
    </style>
</head>
<body>

<script src="js/dat.gui.min.js"></script>
<script src="js/three.min.js"></script>
<script>
(function () {
    'use strict';

    var scene,
        camera,
        renderer,
        container,
        controller,
        newObj,
        objects = [],
        isMouseDown,
        object = undefined,
        onMouseDownPosition = new THREE.Vector2(),
        radius = 400,
        theta = 45,
        onMouseDownTheta = 45,
        phi = 60,
        onMouseDownPhi = 60,
        mouse,
        raycaster = new THREE.Raycaster();

    // Initialize the scene
    init();

    // Animate the scene
    animate();

    function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        renderer = new THREE.WebGLRenderer( {antialias: true} );

        // Set the background color of the renderer to grey, with full opacity
        renderer.setClearColor( 0xF0F0F0, 1 );

        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild(renderer.domElement);

        // Create the scene, in which all objects are stored
        // (e. g. camera, lights, geometries, ...)
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
                40, window.innerWidth / window.innerHeight, 1, 10000
        );
        //camera.position.y = 80;
       // camera.position.z = 400;
        camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
        camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
        camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
        //camera.target.position.y = 200;


        camera.lookAt(scene.position)

        // Create Grid
        var gridXZ = new THREE.GridHelper(100, 10);
        gridXZ.setColors(
                new THREE.Color(0x0f0f0f),
                new THREE.Color(0x0f0f0f)
        );
        gridXZ.position.set( 0,0, 0);
        scene.add(gridXZ);





        initUI();
        initUIEvents();
    }

    function initUI() {
        controller = {

            addSphere: function () {
                addSphere();
            },
            addBox: function () {
                addCube()
            },
            addCylinder: function () {
                addCylinder()
            },

            ry: 0.0,
            rz: 0.0,
            rx: 0.0,

            my: 0.0,
            mz: 0.0,
            mx: 0.0
        };

        var gui = new dat.GUI();
        var h = gui.addFolder("add new object");
        h.add(controller, 'addSphere').name('new sphere');
        h.add(controller, 'addBox').name('new cube');
        h.add(controller, 'addCylinder').name('new cylinder');


        h = gui.addFolder("object actions");
        h.add(controller, "rx", -180.0, 180.0, 0.025).name("rotate x").listen();
        h.add(controller, "ry", -180.0, 180.0, 0.025).name("rotate y").listen();
        h.add(controller, "rz", -180.0, 180.0, 0.025).name("rotate z").listen();

        h.add(controller, "mx", -100.0, 100.0, 0.025).name("move x").listen();
        h.add(controller, "my", -100.0, 100.0, 0.025).name("move y").listen();
        h.add(controller, "mz", -100.0, 100.0, 0.025).name("move z").listen();
    }

    function initUIEvents() {

        container.addEventListener( 'mousedown', onMouseDown, false );
        container.addEventListener( 'mousemove', onMouseMove, false );
        container.addEventListener( 'mouseup', onMouseUp, false );

        window.addEventListener( 'resize', onWindowResize, false );
    }

    function addSphere() {

        newObj = new THREE.Mesh(
                new THREE.SphereGeometry(20, 20, 10),
                new THREE.MeshNormalMaterial()
        );

        setRandomPos(newObj);

        newObj.overdraw = true;

        objects.push(newObj);

        scene.add(newObj);
    }

    function addCube() {

        newObj = new THREE.Mesh(
                new THREE.BoxGeometry(30, 30, 30),
                new THREE.MeshNormalMaterial()
        );

        setRandomPos(newObj);

        objects.push(newObj);

        scene.add(newObj);
    }

    function addCylinder() {

        newObj = new THREE.Mesh(
                new THREE.CylinderGeometry(20, 20, 20, 50, false),
                new THREE.MeshNormalMaterial()
        );

        setRandomPos(newObj);

        objects.push(newObj);

        scene.add(newObj);
    }

    // set random position of an object from -100 to 100 units
    function setRandomPos(obj) {
        obj.position.x = Math.floor(Math.random() * (100 - (-100) + 1)) + (-100);
        obj.position.y = Math.floor(Math.random() * (100 - (-100) + 1)) + (-100);
        obj.position.z = Math.floor(Math.random() * (100 - (-100) + 1)) + (-100);
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight);
    }

    function onMouseDown( event ) {

        isMouseDown = true;

        onMouseDownTheta = theta;
        onMouseDownPhi = phi;
        onMouseDownPosition.x = event.clientX;
        onMouseDownPosition.y = event.clientY;
//
//        mouseXOnMouseDown = event.clientX - sizeX;
//        targetRotationOnMouseDownX = targetRotationX;
//
//        mouseYOnMouseDown = event.clientY - sizeY;
//        targetRotationOnMouseDownY = targetRotationY;
        mouse = new THREE.Vector3(2*(event.clientX / window.innerWidth) - 1,
        1 - 2 * (event.clientY / window.innerHeight));

        //var projector = new THREE.Projector();
        //projector.pickingRay(mouseVektor.clone(), camera);
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects( objects );

        if (intersects.length) {

            object = intersects[0].object;
            controller.mx = object.position.x;
            controller.my = object.position.y;
            controller.mz = object.position.z;



            console.log(object);

        }

    }

    function onMouseMove( event ) {


//        targetRotationY = targetRotationOnMouseDownY + (mouseY - mouseYOnMouseDown) * 0.02;
//        targetRotationX = targetRotationOnMouseDownX + (mouseX - mouseXOnMouseDown) * 0.02;

        mouse = new THREE.Vector3(
                2*(event.clientX / window.innerWidth) - 1,
                1 - 2 * (event.clientY / window.innerHeight)
        );


        if ( isMouseDown ) {

            theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
            phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

            phi = Math.min( 180, Math.max( 0, phi ) );

            camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
            camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
            camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
            //camera.updateMatrix();
            camera.lookAt(scene.position);
        }

        //var projector = new THREE.Projector();
        //projector.pickingRay(mouseVektor.clone(), camera);
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects( objects );

        if (intersects.length) {
            container.style.cursor = 'pointer';
            console.log('sss');
        } else {
            container.style.cursor = 'default';

        }
    }

    function onMouseUp () {

        isMouseDown = false;
    }

    function animate(){

        requestAnimationFrame(animate);
        render();
    }

    function render() {

        if (object) {
            object.rotation.x = controller.rx * Math.PI/180;
            object.rotation.y = controller.ry * Math.PI/180;
            object.rotation.z = controller.rz * Math.PI/180;

            object.position.x = controller.mx;
            object.position.y = controller.my;
            object.position.z = controller.mz;
        }

        renderer.render( scene, camera );
    }
})();
</script>
</body>
</html>