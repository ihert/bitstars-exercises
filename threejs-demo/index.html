<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>three.js demo</title>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
<script>

    // Global scene object
    var scene;

    // Global camera object
    var camera;

    var renderer;

    // Global mesh object of the pyramid
    var pyramidMesh;

    // Global mesh object of the cube
    var cube;

    var sizeX = window.innerWidth - 20;
    var sizeY = window.innerHeight - 20;

    var targetRotationX = 0;
    var targetRotationOnMouseDownX = 0;

    var targetRotationY = 0;
    var targetRotationOnMouseDownY = 0;

    var mouseX = 0;
    var mouseXOnMouseDown = 0;

    var mouseY = 0;
    var mouseYOnMouseDown = 0;

    // Initialize the scene
    init();

    // Animate the scene
    animate();

    function init() {
        renderer = new THREE.WebGLRenderer();

        // Set the background color of the renderer to grey, with full opacity
        renderer.setClearColor( 0x313638, 1 );

        renderer.setSize( sizeX, sizeY );

        document.body.appendChild( renderer.domElement );

        // Create the scene, in which all objects are stored
        // (e. g. camera, lights, geometries, ...)
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
                45, window.innerWidth / window.innerHeight, 0.1, 100
        );
        camera.position.set(0, 0, 10);
        camera.lookAt(scene.position);
        scene.add(camera);

        // Create the cube
        // Parameter 1: Width
        // Parameter 2: Height
        // Parameter 3: Depth
        var boxGeometry = new THREE.BoxGeometry( 3, 3, 3 );

        // Create a mesh and insert the geometry and the material and add the
        // mesh to the scene
        cube = new THREE.Mesh(
                boxGeometry, new THREE.MeshLambertMaterial( {color: 0xFA5858} )
        );
        cube.position.set( 0.0 , 0.5, 0.0 );
        scene.add(cube);

        // Create Grid
        var grid = new THREE.GridHelper( 7, 1 );
        grid.setColors( 0xCCCCCC, 0xFFFFFF );
        grid.position.set( 0.0, -1.0, 0.0 );
        scene.add( grid );

        // Let there be light ;)
        var light = new THREE.SpotLight( 0xffffff, 1.5 );
        light.position.set( 0.0, 500, 2000 );
        light.castShadow = true;
        light.shadowCameraNear = 200;
        light.shadowCameraFar = camera.far;
        light.shadowCameraFov = 50;
        light.shadowBias = -0.00022;
        light.shadowDarkness = 0.5;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        scene.add(light);

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );

        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth - 20, window.innerHeight - 20);

    }

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mouseout', onDocumentMouseOut, false );

        mouseXOnMouseDown = event.clientX - sizeX;
        targetRotationOnMouseDownX = targetRotationX;

        mouseYOnMouseDown = event.clientY - sizeY;
        targetRotationOnMouseDownY = targetRotationY;
    }

    function onDocumentMouseMove( event ) {

        mouseX = event.clientX - sizeX;
        mouseY = event.clientY - sizeY;

        targetRotationY = targetRotationOnMouseDownY + (mouseY - mouseYOnMouseDown) * 0.02;
        targetRotationX = targetRotationOnMouseDownX + (mouseX - mouseXOnMouseDown) * 0.02;
    }

    function onDocumentMouseUp() {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
    }

    function onDocumentMouseOut() {

        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
    }

    function animate(){

        requestAnimationFrame(animate);

        render();
    }

    function render() {

        //horizontal rotation
        cube.rotation.y += ( targetRotationX - cube.rotation.y ) * 0.1;

        //vertical rotation
        var finalRotationY = (targetRotationY - cube.rotation.x);


        if ( cube.rotation.x <= 1 && cube.rotation.x >= -1 ) {

            cube.rotation.x += finalRotationY * 0.1;
        }
        if ( cube.rotation.x > 1 ) {

            cube.rotation.x = 1
        }
        else if ( cube.rotation.x < -1 ) {

            cube.rotation.x = -1
        }

        renderer.render( scene, camera );
    }
</script>
</body>
</html>